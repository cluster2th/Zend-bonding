{
  "language": "Solidity",
  "sources": {
    "src/bonding/CustomBond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\nimport \"../types/BondOwnable.sol\";\nimport \"../libraries/SafeMath.sol\";\nimport \"../libraries/SafeERC20.sol\";\nimport \"../libraries/FixedPoint.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IHelper.sol\";\nimport \"./Fees.sol\";\n\ncontract CustomBond is BondOwnable {\n    using FixedPoint for *;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    event BondCreated(uint256 deposit, uint256 payout, uint256 expires);\n\n    event BondRedeemed(address recipient, uint256 payout, uint256 remaining);\n\n    event BondPriceChanged(uint256 internalPrice, uint256 debtRatio);\n\n    event ControlVariableAdjustment(uint256 initialBCV, uint256 newBCV, uint256 adjustment, bool addition);\n\n    event LPAdded(address lpAddress, uint256 lpAmount);\n\n    IERC20 public immutable PAYOUT_TOKEN; // token paid for principal\n    ITreasury public immutable CUSTOM_TREASURY; // pays for and receives principal\n    address public immutable SUBSIDY_ROUTER; // pays subsidy in TAO to custom treasury\n    address public immutable HELPER; // helper for helping swap, lend to get lp token\n    address public immutable FEES; // Fees contract\n    address public OLY_TREASURY; // receives fee\n    address public principalToken; // inflow token\n    uint256 public totalPrincipalBonded;\n    uint256 public totalPayoutGiven;\n    uint256 public totalDebt; // total value of outstanding bonds; used for pricing\n    uint256 public lastDecay; // reference block for debt decay\n    uint256 public payoutSinceLastSubsidy; // principal accrued since subsidy paid\n    uint256 public maxFeeAllowed = 50000; //maximum amount of fee allowed to charged - 5%\n    Terms public terms; // stores terms for new bonds\n    Adjust public adjustment; // stores adjustment to BCV data\n    bool public lpTokenAsFeeFlag;//\n    bool public bondWithOneAssetFlag;\n\n    mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n    // Info for creating new bonds\n    struct Terms {\n        uint256 controlVariable; // scaling variable for price\n        uint256 vestingTerm; // in blocks\n        uint256 minimumPrice; // vs principal value\n        uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n        uint256 maxDebt; // payout token decimal debt ratio, max % total supply created as debt\n    }\n\n    // Info for bond holder\n    struct Bond {\n        uint256 payout; // payout token remaining to be paid\n        uint256 vesting; // Blocks left to vest\n        uint256 lastBlock; // Last interaction\n        uint256 truePricePaid; // Price paid (principal tokens per payout token) in ten-millionths - 4000000 = 0.4\n    }\n\n    // Info for incremental adjustments to control variable\n    struct Adjust {\n        bool add; // addition or subtraction\n        uint256 rate; // increment\n        uint256 target; // BCV when adjustment finished\n        uint256 buffer; // minimum length (in blocks) between adjustments\n        uint256 lastBlock; // block when last adjustment made\n    }\n\n    receive() external payable {}\n\n    constructor(\n        address _customTreasury,\n        address _payoutToken,\n        address _principalToken,\n        address _olyTreasury,\n        address _subsidyRouter,\n        address _initialOwner,\n        address _helper,\n        address _fees\n    ) {\n        require(_customTreasury != address(0), \"Factory: customTreasury bad\");\n        CUSTOM_TREASURY = ITreasury(_customTreasury);\n        require(_payoutToken != address(0), \"Factory: payoutToken bad\");\n        PAYOUT_TOKEN = IERC20(_payoutToken);\n        require(_principalToken != address(0), \"Factory: principalToken bad\");\n        principalToken = _principalToken;\n        require(_olyTreasury != address(0), \"Factory: olyTreasury bad\");\n        OLY_TREASURY = _olyTreasury;\n        require(_subsidyRouter != address(0), \"Factory: subsidyRouter bad\");\n        SUBSIDY_ROUTER = _subsidyRouter;\n        require(_initialOwner != address(0), \"Factory: initialOwner bad\");\n        policy = _initialOwner;\n        bondManager = _initialOwner;\n        require(_helper != address(0), \"Factory: helper bad\");\n        HELPER = _helper;\n        require(_fees != address(0), \"Factory: FEES bad\");\n        FEES = _fees;\n\n        lpTokenAsFeeFlag = true;\n    }\n\n    /* ======== INITIALIZATION ======== */\n\n    /**\n     *  @notice initializes bond parameters\n     *  @param _controlVariable uint\n     *  @param _vestingTerm uint\n     *  @param _minimumPrice uint\n     *  @param _maxPayout uint\n     *  @param _maxDebt uint\n     *  @param _initialDebt uint\n     */\n    function initializeBond(\n        uint256 _controlVariable,\n        uint256 _vestingTerm,\n        uint256 _minimumPrice,\n        uint256 _maxPayout,\n        uint256 _maxDebt,\n        uint256 _initialDebt\n    ) external onlyPolicy {\n\n        require(terms.controlVariable == 0 && _controlVariable > 0, \"initializeBond: controlVariable must be 0\");\n\n        require(_vestingTerm >= 10000, \"Vesting must be longer than 36 hours\");\n\n        require(_maxPayout <= 1000, \"Payout cannot be above 1 percent\");\n\n        terms = Terms({\n            controlVariable: _controlVariable,\n            vestingTerm: _vestingTerm,\n            minimumPrice: _minimumPrice,\n            maxPayout: _maxPayout,\n            maxDebt: _maxDebt\n        });\n\n        totalDebt = _initialDebt;\n        lastDecay = block.number;\n        CUSTOM_TREASURY.toggleBondContract(address(this));\n    }\n\n    /// @notice set fee flag\n    /// @param _lpTokenAsFeeFlag bool\n    function setLPtokenAsFee(bool _lpTokenAsFeeFlag) external onlyPolicy {\n        lpTokenAsFeeFlag = _lpTokenAsFeeFlag;\n    }\n\n    /* ======== POLICY FUNCTIONS ======== */\n\n    enum PARAMETER {\n        VESTING,\n        PAYOUT,\n        DEBT\n    }\n\n    /**\n     *  @notice set parameters for new bonds\n     *  @param _parameter PARAMETER\n     *  @param _input uint\n     */\n    function setBondTerms(PARAMETER _parameter, uint256 _input) external onlyBondManager {\n        if (_parameter == PARAMETER.VESTING) {// 0\n            require(_input >= 10000, \"Vesting must be longer than 36 hours\");\n            terms.vestingTerm = _input;\n        } else if (_parameter == PARAMETER.PAYOUT) {// 1\n            require(_input <= 1000, \"Payout cannot be above 1 percent\");\n            terms.maxPayout = _input;\n        } else if (_parameter == PARAMETER.DEBT) {// 2\n            terms.maxDebt = _input;\n        }\n    }\n\n    /**\n     *  @notice set control variable adjustment\n     *  @param _addition bool\n     *  @param _increment uint\n     *  @param _target uint\n     *  @param _buffer uint\n     */\n    function setAdjustment(\n        bool _addition,\n        uint256 _increment,\n        uint256 _target,\n        uint256 _buffer\n    ) external onlyBondManager {\n        require(_increment <= terms.controlVariable.mul(30).div(1000), \"Increment too large\");\n        require(_target > 0, \"setAdjustment: target greater than 0\");\n\n        adjustment = Adjust({\n            add: _addition,\n            rate: _increment,\n            target: _target,\n            buffer: _buffer,\n            lastBlock: block.number\n        });\n    }\n\n    /**\n     *  @notice change address of Treasury\n     *  @param _olyTreasury uint\n     */\n    function changeOlyTreasury(address _olyTreasury) external {\n        address dao = Fees(FEES).DAO();\n        require(msg.sender == dao, \"changeOlyTreasury: Only DAO can replace OLY_TREASURY\");\n        OLY_TREASURY = _olyTreasury;\n    }\n\n    /**\n     *  @notice subsidy controller checks payouts since last subsidy and resets counter\n     *  @return payoutSinceLastSubsidy_ uint\n     */\n    function paySubsidy() external returns (uint256 payoutSinceLastSubsidy_) {\n        require(msg.sender == SUBSIDY_ROUTER, \"Only subsidy controller\");\n\n        payoutSinceLastSubsidy_ = payoutSinceLastSubsidy;\n        payoutSinceLastSubsidy = 0;\n    }\n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice deposit bond\n     *  @param _amount uint\n     *  @param _maxPrice uint\n     *  @param _depositor address\n     *  @return uint\n     */\n    function deposit(\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _depositor\n    ) external returns (uint256) {\n        require(_depositor != address(0), \"Invalid address\");\n\n        return __deposit(_amount, _maxPrice, principalToken, _depositor, true);\n    }\n\n    /**\n     *  @notice deposit bond with an asset(i.e: USDT)\n     *  @param _depositAmount amount of deposit asset\n     *  @param _depositAsset deposit asset\n     *  @param _incomingAsset asset address for swap from deposit asset\n     *  @param _depositor address of depositor\n     *  @return uint\n     */\n    function depositWithAsset(\n        uint256 _depositAmount,\n        uint256 _maxPrice,\n        address _depositAsset,\n        address _incomingAsset,\n        address _depositor\n    ) external returns (uint256) {\n        require(_depositor != address(0), \"depositWithAsset: Invalid depositor\");\n\n        (address lpAddress, uint256 lpAmount) = __lpAddressAndAmount(_depositAmount, _depositAsset, _incomingAsset);\n\n        // remain payoutToken is transferred to user\n        __transferAssetToCaller(msg.sender, address(PAYOUT_TOKEN));\n\n        require(lpAddress != address(0), \"depositWithAsset: Invalid lpAddress\");\n\n        require(lpAmount > 0, \"depositWithAsset: Insufficient lpAmount\");\n\n        return __deposit(lpAmount, _maxPrice, lpAddress, _depositor, false);\n    }\n\n\n    /// @notice internal process of deposit()\n    /// @param _lpAmount amount of principleToken\n    /// @param _maxPrice amount\n    /// @param _lpAddress principleToken\n    /// @param _depositor address of depositor\n    /// @param _flag if deposit(), true and if depositWithAsset(), false\n    /// @return uint\n    function __deposit(\n        uint256 _lpAmount,\n        uint256 _maxPrice,\n        address _lpAddress,\n        address _depositor,\n        bool _flag\n    ) internal returns (uint256) {\n        \n        decayDebt();\n        \n        require(totalDebt <= terms.maxDebt, \"Max capacity reached\");\n\n        uint256 nativePrice = trueBondPrice();\n\n        require(_maxPrice >= nativePrice, \"Slippage limit: more than max price\"); // slippage protection\n\n        uint256 value = CUSTOM_TREASURY.valueOfToken(_lpAddress, _lpAmount);\n        uint256 payout = _payoutFor(value); // payout to bonder is computed\n\n        // must be > 0.01 payout token ( underflow protection )\n        require(payout >= 10**PAYOUT_TOKEN.decimals() / 100, \"Bond too small\");\n\n        require(payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n        // principal is transferred in\n        // approved and deposited into the treasury, returning (_amount - profit) payout token\n         if(_flag) {\n            IERC20(_lpAddress).safeTransferFrom(msg.sender, address(this), _lpAmount);\n         }\n\n        // profits are calculated\n        uint256 fee;\n\n        // principal is been taken as fee and trasfered to dao\n        if (lpTokenAsFeeFlag) {\n            fee = _lpAmount.mul(currentFluxFee()).div(1e6);\n            if (fee != 0) {\n                IERC20(_lpAddress).transfer(OLY_TREASURY, fee);\n            }\n        } else {\n            fee = payout.mul(currentFluxFee()).div(1e6);\n        }\n\n        IERC20(_lpAddress).approve(address(CUSTOM_TREASURY), _lpAmount);\n        CUSTOM_TREASURY.deposit(_lpAddress, _lpAmount.sub(fee), payout);\n\n        if (!lpTokenAsFeeFlag && fee != 0) { // fee is transferred to dao\n            PAYOUT_TOKEN.transfer(OLY_TREASURY, fee);\n        }\n\n        // total debt is increased\n        totalDebt = totalDebt.add(value);\n\n        // depositor info is stored\n        if(lpTokenAsFeeFlag){\n            bondInfo[_depositor] = Bond({\n                payout: bondInfo[_depositor].payout.add(payout),\n                vesting: terms.vestingTerm,\n                lastBlock: block.number,\n                truePricePaid: trueBondPrice()\n            });\n        } else {\n            bondInfo[_depositor] = Bond({\n                payout: bondInfo[_depositor].payout.add(payout.sub(fee)),\n                vesting: terms.vestingTerm,\n                lastBlock: block.number,\n                truePricePaid: trueBondPrice()\n            });\n        }\n\n        // indexed events are emitted\n        emit BondCreated(_lpAmount, payout, block.number.add(terms.vestingTerm));\n        emit BondPriceChanged(_bondPrice(), debtRatio());\n\n        totalPrincipalBonded = totalPrincipalBonded.add(_lpAmount); // total bonded increased\n        totalPayoutGiven = totalPayoutGiven.add(payout); // total payout increased\n        payoutSinceLastSubsidy = payoutSinceLastSubsidy.add(payout); // subsidy counter increased\n\n        adjust(); // control variable is adjusted\n        return payout;\n    }\n\n    /**\n     *  @notice redeem bond for user\n     *  @return uint\n     */\n    function redeem(address _depositor) external returns (uint) {\n        Bond memory info = bondInfo[_depositor];\n\n        uint percentVested = percentVestedFor(_depositor); // (blocks since last interaction / vesting term remaining)\n\n        if (percentVested >= 10000) { // if fully vested\n            delete bondInfo[_depositor]; // delete user info\n            emit BondRedeemed(_depositor, info.payout, 0); // emit bond data\n\n            if(info.payout > 0) {\n                PAYOUT_TOKEN.transfer(_depositor, info.payout);\n            }\n\n            return info.payout;\n        } else { // if unfinished\n            // calculate payout vested\n            uint256 payout = info.payout.mul(percentVested).div(10000);\n\n            // store updated deposit info\n            bondInfo[_depositor] = Bond({\n                payout: info.payout.sub(payout),\n                vesting: info.vesting.sub(block.number.sub(info.lastBlock)),\n                lastBlock: block.number,\n                truePricePaid: info.truePricePaid\n            });\n\n            emit BondRedeemed(_depositor, payout, bondInfo[_depositor].payout);\n\n            if(payout > 0) {\n                PAYOUT_TOKEN.transfer(_depositor, payout);\n            }\n\n            return payout;\n        }\n    }\n\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n    /// @notice makes incremental adjustment to control variable\n    function adjust() internal {\n        uint256 blockCanAdjust = adjustment.lastBlock.add(adjustment.buffer);\n        if (adjustment.rate != 0 && block.number >= blockCanAdjust) {\n            uint256 initial = terms.controlVariable;\n            if (adjustment.add) {\n                terms.controlVariable = terms.controlVariable.add(adjustment.rate);\n                if (terms.controlVariable >= adjustment.target) {\n                    adjustment.rate = 0;\n                }\n            } else {\n                terms.controlVariable = terms.controlVariable.sub(adjustment.rate);\n                if (terms.controlVariable <= adjustment.target) {\n                    adjustment.rate = 0;\n                }\n            }\n            adjustment.lastBlock = block.number;\n            \n            emit ControlVariableAdjustment(initial, terms.controlVariable, adjustment.rate, adjustment.add);\n        }\n    }\n\n    /**\n     *  @notice reduce total debt\n     */\n    function decayDebt() internal {\n        totalDebt = totalDebt.sub(debtDecay());\n        lastDecay = block.number;\n    }\n\n    /**\n     *  @notice calculate current bond price and remove floor if above\n     *  @return price_ uint\n     */\n    function _bondPrice() internal returns (uint256 price_) {\n        price_ = terms.controlVariable.mul(debtRatio()).div(10**(uint256(PAYOUT_TOKEN.decimals()).sub(5)));\n        if (price_ < terms.minimumPrice) {\n            price_ = terms.minimumPrice;\n        } else if (terms.minimumPrice != 0) {\n            terms.minimumPrice = 0;\n        }\n    }\n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     *  @notice calculate current bond premium\n     *  @return price_ uint\n     */\n    function bondPrice() public view returns (uint256 price_) {\n        price_ = terms.controlVariable.mul(debtRatio()).div(10**(uint256(PAYOUT_TOKEN.decimals()).sub(5)));\n        if (price_ < terms.minimumPrice) {\n            price_ = terms.minimumPrice;\n        }\n    }\n\n    /**\n     *  @notice calculate true bond price a user pays\n     *  @return price_ uint\n     */\n    function trueBondPrice() public view returns (uint256 price_) {\n        price_ = bondPrice().add(bondPrice().mul(currentFluxFee()).div(1e6));\n    }\n\n    /**\n     *  @notice determine maximum bond size\n     *  @return uint\n     */\n    function maxPayout() public view returns (uint) {\n        uint256 totalSupply = PAYOUT_TOKEN.totalSupply();\n        if(totalSupply > 10**18*10**PAYOUT_TOKEN.decimals()) totalSupply = 10**18*10**PAYOUT_TOKEN.decimals();\n        return totalSupply.mul(terms.maxPayout).div(100000);\n    }\n\n    /**\n     *  @notice calculate total interest due for new bond\n     *  @param _value uint\n     *  @return uint\n     */\n    function _payoutFor(uint256 _value) internal view returns (uint256) {\n        return FixedPoint.fraction(_value, bondPrice()).decode112with18().div(1e11);\n    }\n\n    /**\n     *  @notice calculate user's interest due for new bond, accounting for Flux Fee\n     *  @param _value uint\n     *  @return uint\n     */\n    function payoutFor(uint256 _value) external view returns (uint256) {\n        uint256 total = FixedPoint.fraction(_value, bondPrice()).decode112with18().div(1e11);\n        return total.sub(total.mul(currentFluxFee()).div(1e6));\n    }\n\n    /**\n     *  @notice calculate current ratio of debt to payout token supply\n     *  @notice protocols using Flux Pro should be careful when quickly adding large %s to total supply\n     *  @return debtRatio_ uint\n     */\n    function debtRatio() public view returns (uint256 debtRatio_) {\n        debtRatio_ = FixedPoint\n            .fraction(currentDebt().mul(10**PAYOUT_TOKEN.decimals()), PAYOUT_TOKEN.totalSupply())\n            .decode112with18()\n            .div(1e18);\n    }\n\n    /**\n     *  @notice calculate debt factoring in decay\n     *  @return uint\n     */\n    function currentDebt() public view returns (uint256) {\n        return totalDebt.sub(debtDecay());\n    }\n\n    /**\n     *  @notice amount to decay total debt by\n     *  @return decay_ uint\n     */\n    function debtDecay() public view returns (uint256 decay_) {\n        uint256 blocksSinceLast = block.number.sub(lastDecay);\n        decay_ = totalDebt.mul(blocksSinceLast).div(terms.vestingTerm);\n        if (decay_ > totalDebt) {\n            decay_ = totalDebt;\n        }\n    }\n\n    /**\n     *  @notice calculate how far into vesting a depositor is\n     *  @param _depositor address\n     *  @return percentVested_ uint\n     */\n    function percentVestedFor(address _depositor) public view returns (uint256 percentVested_) {\n        Bond memory bond = bondInfo[_depositor];\n        uint256 blocksSinceLast = block.number.sub(bond.lastBlock);\n        uint256 vesting = bond.vesting;\n\n        if (vesting > 0) {\n            percentVested_ = blocksSinceLast.mul(10000).div(vesting);\n        } else {\n            percentVested_ = 0;\n        }\n    }\n\n    /**\n     *  @notice calculate amount of payout token available for claim by depositor\n     *  @param _depositor address\n     *  @return pendingPayout_ uint\n     */\n    function pendingPayoutFor(address _depositor) external view returns (uint256 pendingPayout_) {\n        uint256 percentVested = percentVestedFor(_depositor);\n        uint256 payout = bondInfo[_depositor].payout;\n\n        if (percentVested >= 10000) {\n            pendingPayout_ = payout;\n        } else {\n            pendingPayout_ = payout.mul(percentVested).div(10000);\n        }\n    }\n\n    /**\n     *  @notice current fee Flux takes of each bond\n     *  @return currentFee_ uint\n     */\n    function currentFluxFee() public view returns (uint256 currentFee_) {\n\n        uint256[] memory tierCeilings = Fees(FEES).getTierCeilings();\n        uint256[] memory fees = Fees(FEES).getFees();\n\n        uint256 feesLength = fees.length;\n        for (uint256 i; i < feesLength; i++) {\n            if (totalPrincipalBonded < tierCeilings[i] || i == feesLength - 1) {\n                if(fees[i] > maxFeeAllowed){\n                    return maxFeeAllowed;\n                }else{\n                    return fees[i];\n                }\n\n            }\n        }\n    }\n\n    /// @dev Helper to transfer full contract balances of assets to the caller\n    function __transferAssetToCaller(address _caller, address _asset) private {\n        uint256 transferAmount = IERC20(_asset).balanceOf(address(this));\n        if (transferAmount > 0) {\n            IERC20(_asset).safeTransfer(_caller, transferAmount);\n        }\n    }\n\n    /// @notice Swap and AddLiquidity on the UniswapV2\n    function __lpAddressAndAmount(\n        uint256 _depositAmount,\n        address _depositAsset,\n        address _incomingAsset\n    ) public payable returns (address lpAddress_, uint256 lpAmount_) {\n\n        if(_depositAsset == address(0)) {//ETH\n            payable(address(HELPER)).transfer(address(this).balance);\n        } else {\n            IERC20(_depositAsset).safeTransferFrom(msg.sender, address(this), _depositAmount);\n\n            IERC20(_depositAsset).approve(address(HELPER), _depositAmount);\n        }\n\n        bytes memory swapArgs = abi.encode(_depositAmount, _depositAsset, address(PAYOUT_TOKEN), _incomingAsset);\n\n        (lpAddress_, lpAmount_) = IHelper(HELPER).swapForDeposit(swapArgs);\n\n        emit LPAdded(lpAddress_, lpAmount_);\n    }\n}\n"
    },
    "src/types/BondOwnable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\ncontract BondOwnable {\n    address public policy;\n    address public bondManager;\n\n    constructor() {\n        policy = msg.sender;\n        bondManager = msg.sender;\n    }\n\n    modifier onlyPolicy() {\n        require(msg.sender == policy, \"BondOwnable: caller is not the owner\");\n        _;\n    }\n\n    modifier onlyBondManager() {\n        require(msg.sender == bondManager, \"BondOwnable: caller is not the bond manager\");\n        _;\n    }\n    function transferBondManagement(address _newManager) external onlyPolicy {\n        require(_newManager != address(0), \"BondOwnable: _newManager must not be zero address\");\n        bondManager = _newManager;\n    }\n\n    function transferOwnership(address _newOwner) external onlyPolicy {\n        require(_newOwner != address(0), \"BondOwnable: newOwner must not be zero address\");\n        policy = _newOwner;\n    }\n}\n"
    },
    "src/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n\n    function sqrrt(uint256 a) internal pure returns (uint256 c) {\n        if (a > 3) {\n            c = a;\n            uint256 b = add(div(a, 2), 1);\n            while (b < c) {\n                c = b;\n                b = div(add(div(a, b), b), 2);\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n}\n"
    },
    "src/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\nimport \"../libraries/SafeMath.sol\";\nimport \"../libraries/Address.sol\";\nimport \"../interfaces/IERC20.sol\";\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            \"SafeERC20: decreased allowance below zero\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\nimport \"../libraries/FullMath.sol\";\nimport \"../libraries/Babylonian.sol\";\nimport \"../libraries/BitMath.sol\";\n\nlibrary FixedPoint {\n    struct Uq112x112 {\n        uint224 _x;\n    }\n\n    struct Uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    function decode(Uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    function decode112with18(Uq112x112 memory self) internal pure returns (uint256) {\n        return uint256(self._x) / 5192296858534827;\n    }\n\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (Uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint::fraction: division by zero\");\n        if (numerator == 0) return FixedPoint.Uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return Uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return Uq112x112(uint224(result));\n        }\n    }\n\n    // square root of a Uq112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(Uq112x112 memory self) internal pure returns (Uq112x112 memory) {\n        if (self._x <= uint144(-1)) {\n            return Uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return Uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n    }\n}\n"
    },
    "src/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\n/// @title CustomTreasury Interface\ninterface ITreasury {\n        \n    function deposit(\n        address _principleTokenAddress,\n        uint256 _amountPrincipleToken,\n        uint256 _amountPayoutToken\n    ) external;\n\n    function valueOfToken(\n        address _principleTokenAddress, \n        uint256 _amount\n    ) external view returns (uint256 value_);\n\n    function toggleBondContract(address _bondContract) external;\n}\n"
    },
    "src/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "src/interfaces/IHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\n/// @notice Interface for Helper\ninterface IHelper {\n\n    function swapForDeposit(\n        bytes calldata _swapArgs\n    ) external returns (address lpAddress_, uint256 lpAmount_);\n\n}\n"
    },
    "src/bonding/Fees.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\nimport \"../libraries/SafeMath.sol\";\n\ncontract Fees {    \n    using SafeMath for uint256;\n    \n    address public DAO;\n\n    uint256[] private tierCeilings; \n    uint256[] private fees;\n\n    event FeesAndTierCeilings(uint256[] tierCeilings, uint256[] fees);\n\n    modifier onlyDAO() {\n        require(msg.sender == DAO, \"Only DAO call\");\n        _;\n    }\n\n    constructor(address _dao) {\n        require(_dao != address(0), \"Fees: DAO bad address\");\n        DAO = _dao;\n    }\n\n    /// @notice set fee for creating bond\n    /// @param _tierCeilings uint[]\n    /// @param _fees uint[]\n    function setTiersAndFees(\n        uint256[] calldata _tierCeilings, \n        uint256[] calldata _fees\n    ) external onlyDAO {\n        require(_tierCeilings.length == _fees.length, \"setTiersAndFees: Bad items length\");\n\n        uint256 feeSum = 0;\n        for (uint256 i; i < _fees.length; i++) {\n            feeSum = feeSum.add(_fees[i]);\n        }\n        \n        require(feeSum > 0, \"setTiersAndFees: Bad fees\");\n\n        for (uint256 i; i < _fees.length; i++) {\n            tierCeilings.push(_tierCeilings[i]);\n            fees.push(_fees[i]);\n        }\n\n        emit FeesAndTierCeilings(_tierCeilings, _fees);\n    }\n\n    /// @notice Get fees for bond\n    function getFees() external view returns (uint256[] memory) {\n        return fees;\n    }\n\n    /// @notice Get tierCeilings for bond\n    function getTierCeilings() external view returns (uint256[] memory) {\n        return tierCeilings;\n    }\n}"
    },
    "src/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function addressToString(address _address) internal pure returns (string memory) {\n        bytes32 _bytes = bytes32(uint256(_address));\n        bytes memory _hex = \"0123456789abcdef\";\n        bytes memory _addr = new bytes(42);\n\n        _addr[0] = \"0\";\n        _addr[1] = \"x\";\n\n        for (uint256 i = 0; i < 20; i++) {\n            _addr[2 + i * 2] = _hex[uint8(_bytes[i + 12] >> 4)];\n            _addr[3 + i * 2] = _hex[uint8(_bytes[i + 12] & 0x0f)];\n        }\n\n        return string(_addr);\n    }\n}\n"
    },
    "src/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 k, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        k = x * y;\n        h = mm - k;\n        if (mm < k) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 k,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        k /= pow2;\n        k += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return k * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 k, uint256 h) = fullMul(x, y);\n        uint256 mm = mulmod(x, y, d);\n        if (mm > k) h -= 1;\n        k -= mm;\n        require(h < d, \"FullMath::mulDiv: overflow\");\n        return fullDiv(k, h, d);\n    }\n}\n"
    },
    "src/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\nlibrary Babylonian {\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "src/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\nlibrary BitMath {\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, \"BitMath::mostSignificantBit: zero\");\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n}\n"
    },
    "src/bonding/Factory.sol": {
      "content": "\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.7.5;\n\nimport \"../types/BondOwnable.sol\";\nimport \"../libraries/SafeMath.sol\";\nimport \"./CustomBond.sol\";\nimport \"./CustomTreasury.sol\";\nimport \"./Fees.sol\";\nimport \"../interfaces/IFactoryStorage.sol\";\n\ncontract Factory is BondOwnable {    \n    using SafeMath for uint256;\n\n    address immutable public TREASURY;\n    address immutable public FACTORY_STORAGE;\n    address immutable public SUBSIDY_ROUTER;\n    address immutable public HELPER;\n    address immutable public FEES;\n\n    event BondCreation(address treasury, address bond, address _initialOwner);   \n\n    constructor(\n        address _treasury,\n        address _factoryStorage,\n        address _subsidyRouter,\n        address _helper,\n        address _fees\n    ) {\n        require(_treasury != address(0), \"Factory: treasury bad address\");\n        TREASURY = _treasury;\n        require(_factoryStorage != address(0), \"Factory: factoryStorage bad address\");\n        FACTORY_STORAGE = _factoryStorage;\n        require(_subsidyRouter != address(0), \"Factory: subsidyRouter bad address\");\n        SUBSIDY_ROUTER = _subsidyRouter;\n        require(_helper != address(0), \"Factory: helper bad address\");\n        HELPER = _helper;\n        require(_fees != address(0), \"Factory: Fees bad address\");\n        FEES = _fees;\n    }\n\n    /* ======== POLICY FUNCTIONS ======== */\n\n    /**\n        @notice deploys custom treasury and custom bond contracts and returns address of both\n        @param _payoutToken address\n        @param _principleToken address\n        @param _initialOwner address\n        @return _treasury address\n        @return _bond address\n     */\n    function createBondAndTreasury(\n        address _payoutToken,\n        address _principleToken,\n        address _initialOwner\n    ) external returns (address _treasury, address _bond) {\n        \n        uint256[] memory fees = Fees(FEES).getFees();\n        require(fees.length > 0, \"createBondAndTreasury: fees must be setup\");\n\n        CustomTreasury customTreasury = new CustomTreasury(_payoutToken, _initialOwner);\n        CustomBond customBond = new CustomBond(\n            address(customTreasury), \n            _payoutToken, \n            _principleToken, \n            TREASURY, \n            SUBSIDY_ROUTER, \n            _initialOwner, \n            HELPER,\n            FEES\n        );\n\n        emit BondCreation(address(customTreasury), address(customBond), _initialOwner);                \n\n        return IFactoryStorage(FACTORY_STORAGE).pushBond(\n            _payoutToken, \n            _principleToken, \n            address(customTreasury), \n            address(customBond), \n            _initialOwner\n        );\n    }\n\n    /**\n        @notice deploys custom treasury and custom bond contracts and returns address of both\n        @param _payoutToken address\n        @param _principleToken address\n        @param _customTreasury address\n        @param _initialOwner address\n        @return _treasury address\n        @return _bond address\n     */\n    function createBond(\n        address _payoutToken,\n        address _principleToken,\n        address _customTreasury,\n        address _initialOwner\n    ) external returns (address _treasury, address _bond) {\n\n        uint256[] memory fees = Fees(FEES).getFees();\n        require(fees.length > 0, \"createBond: fees must be setup\");\n\n        CustomBond bond = new CustomBond(\n            _customTreasury, \n            _payoutToken, \n            _principleToken, \n            _customTreasury, \n            SUBSIDY_ROUTER, \n            _initialOwner, \n            HELPER,\n            FEES\n        );\n\n        emit BondCreation(_customTreasury, address(bond), _initialOwner);\n\n        return\n            IFactoryStorage(FACTORY_STORAGE).pushBond(\n                _payoutToken,\n                _principleToken,\n                _customTreasury,\n                address(bond),\n                _initialOwner\n            );\n    }\n}\n"
    },
    "src/bonding/CustomTreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\nimport \"../types/BondOwnable.sol\";\nimport \"../libraries/SafeMath.sol\";\nimport \"../libraries/SafeERC20.sol\";\nimport \"../interfaces/IERC20.sol\";\n\ncontract CustomTreasury is BondOwnable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public immutable payoutToken;\n\n    mapping(address => bool) public bondContract;\n\n    event BondContractToggled(address bondContract, bool approved);\n\n    event Withdraw(address token, address destination, uint256 amount);\n\n    constructor(address _payoutToken, address _initialOwner) {\n        require(_payoutToken != address(0), \"CustomTreasury: payoutToken must not be zero address\");\n        payoutToken = _payoutToken;\n        require(_initialOwner != address(0), \"CustomTreasury: initialOwner must not be zero address\");\n        policy = _initialOwner;\n    }\n\n    /* ======== BOND CONTRACT FUNCTION ======== */\n\n    /**\n     *  @notice deposit principle token and recieve back payout token\n     *  @param _principleTokenAddress address\n     *  @param _amountPrincipleToken uint\n     *  @param _amountPayoutToken uint\n     */\n    function deposit(\n        address _principleTokenAddress,\n        uint256 _amountPrincipleToken,\n        uint256 _amountPayoutToken\n    ) external {\n        require(bondContract[msg.sender], \"msg.sender is not a bond contract\");\n        IERC20(_principleTokenAddress).safeTransferFrom(msg.sender, address(this), _amountPrincipleToken);\n        \n        require(IERC20(payoutToken).balanceOf(address(this)) >= _amountPayoutToken, \"deposit: Insufficient payoutToken balance\");\n        IERC20(payoutToken).safeTransfer(msg.sender, _amountPayoutToken);\n    }\n\n    /* ======== VIEW FUNCTION ======== */\n\n    /**\n     *   @notice returns payout token valuation of priciple\n     *   @param _principleTokenAddress address\n     *   @param _amount uint\n     *   @return value_ uint\n     */\n    function valueOfToken(address _principleTokenAddress, uint256 _amount) public view returns (uint256 value_) {\n        // convert amount to match payout token decimals\n        value_ = _amount.mul(10**IERC20(payoutToken).decimals()).div(10**IERC20(_principleTokenAddress).decimals());\n    }\n\n    /* ======== POLICY FUNCTIONS ======== */\n\n    /**\n     *  @notice policy can withdraw ERC20 token to desired address\n     *  @param _token uint\n     *  @param _destination address\n     *  @param _amount uint\n     */\n    function withdraw(\n        address _token,\n        address _destination,\n        uint256 _amount\n    ) external onlyPolicy {\n        IERC20(_token).safeTransfer(_destination, _amount);\n\n        emit Withdraw(_token, _destination, _amount);\n    }\n\n    /**\n        @notice toggle bond contract\n        @param _bondContract address\n     */\n    function toggleBondContract(address _bondContract) external {\n        require(msg.sender == policy || msg.sender == _bondContract, \"Ownable: caller is not the owner\");\n        bondContract[_bondContract] = !bondContract[_bondContract];\n\n        emit BondContractToggled(_bondContract, bondContract[_bondContract]);\n    }\n}\n"
    },
    "src/interfaces/IFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\n/// @title IFactoryStorage Interface\ninterface IFactoryStorage {\n    function pushBond(\n        address _payoutToken,\n        address _principleToken,\n        address _customTreasury,\n        address _customBond,\n        address _initialOwner\n    ) external returns (address _treasury, address _bond);\n}\n"
    },
    "src/bonding/Helper.sol": {
      "content": "\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.7.5;\n\nimport \"../libraries/SafeMath.sol\";\nimport \"../libraries/SafeERC20.sol\";\nimport \"../interfaces/IUniswapV2Router2.sol\";\nimport \"../interfaces/IUniswapV2Factory.sol\";\nimport \"../interfaces/IHelper.sol\";\n\ncontract Helper is IHelper {\n    \n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    \n    address private immutable UNISWAP2_FACTORY;\n    address private immutable UNISWAP2_ROUTER;\n    address private immutable SUSHI_FACTORY;\n    address private immutable SUSHI_ROUTER;\n    address private immutable WETH;\n    IERC20 private constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    /// @dev Provides a standard implementation for transferring assets between\n    /// the msg.sender and the helper, by wrapping the action.\n    modifier transferHandler(bytes memory _encodedArgs) {            \n        (\n            uint256 depositAmount,\n            address depositAsset,\n            address payoutAsset,\n            address incomingAsset\n        ) = __decodeSwapArgs(_encodedArgs);\n        \n        if(depositAsset != address(0)) {\n            IERC20(depositAsset).safeTransferFrom(msg.sender, address(this), depositAmount);\n        }\n\n        // Execute call\n        _;\n\n        // remain asset to send caller back\n        __transferAssetToCaller(msg.sender, depositAsset);\n        __transferAssetToCaller(msg.sender, payoutAsset);\n    }\n    \n    receive() external payable {}\n\n    constructor(\n        address _uniswap2Factory,\n        address _uniswap2Router,\n        address _sushiswapFactory,\n        address _sushiswapRouter\n    ) {\n        require(_uniswap2Factory != address(0), \"Helper: _uniswap2Factory must not be zero address\");\n        require(_uniswap2Router != address(0), \"Helper: _uniswap2Router must not be zero address\");\n        require(_sushiswapFactory != address(0), \"Helper: _sushiswapFactory must not be zero address\");\n        require(_sushiswapRouter != address(0), \"Helper: _sushiswapRouter must not be zero address\");\n\n        UNISWAP2_FACTORY = _uniswap2Factory;\n        UNISWAP2_ROUTER = _uniswap2Router;\n        SUSHI_FACTORY = _sushiswapFactory;    \n        SUSHI_ROUTER = _sushiswapRouter;  \n        WETH = IUniswapV2Router2(_uniswap2Router).WETH();\n    }\n\n    /// @notice get LP token and LP amount\n    /// @param _swapArgs encoded data\n    /// @return lpAddress_ lp token address\n    /// @return lpAmount_ lp token amount\n    function swapForDeposit(bytes calldata _swapArgs)\n        external        \n        override        \n        transferHandler(_swapArgs)\n        returns (address lpAddress_, uint256 lpAmount_)\n    {\n        (lpAddress_, lpAmount_) = __swapForDeposit(_swapArgs);\n    }\n\n    /// Avoids stack-too-deep error.\n    function __swapForDeposit(bytes calldata _swapArgs) private \n        returns (address lpAddress_, uint256 lpAmount_)\n    {\n        (\n            uint256 depositAmount,\n            address depositAsset,\n            address payoutAsset,\n            address incomingAsset\n        ) = __decodeSwapArgs(_swapArgs);\n\n        address router;\n        address factory;\n        uint256 payoutAmount = depositAmount;     \n        address[] memory path = new address[](2);  \n\n        if(depositAsset != payoutAsset) {             \n            path[0] = depositAsset;            \n            if(path[0] == address(0)) {\n                path[0] = WETH;\n            }\n            path[1] = payoutAsset;\n\n            (router,) = __checkPool(path);\n            \n            require(router != address(0), \"Swap: No Pool\");\n\n            // Get payoutAmount from depositAsset on Uniswap/Sushiswap\n            payoutAmount = IUniswapV2Router2(router).getAmountsOut(depositAmount, path)[1];\n            \n            if(path[0] == WETH) {\n                __swapETHToToken(depositAmount, payoutAmount, router, path);\n            } else {\n                __swapTokenToToken(depositAmount, payoutAmount, router, path);\n            }\n        }   \n        \n        path[0] = payoutAsset;\n        path[1] = incomingAsset;\n\n        (router, factory) = __checkPool(path);\n        \n        require(router != address(0), \"Swap: No Pool\");\n\n        uint256 expectedAmount = IUniswapV2Router2(router).getAmountsOut(payoutAmount.div(2), path)[1];\n\n        __swapTokenToToken(payoutAmount.div(2), expectedAmount, router, path);\n        \n        (lpAddress_, lpAmount_) = addLiquidityToken(\n            factory,\n            router,\n            path,\n            payoutAmount,\n            expectedAmount\n        );              \n    }\n\n    /// @notice Swap ERC20 Token to ERC20 Token\n    function __swapTokenToToken(\n        uint256 _payoutAmount,\n        uint256 _expectedAmount,\n        address _router,\n        address[] memory _path\n    ) private returns (uint256[] memory amounts_) {\n        __approveMaxAsNeeded(_path[0], _router, _payoutAmount);\n        \n        amounts_ = IUniswapV2Router2(_router).swapExactTokensForTokens(\n            _payoutAmount,\n            _expectedAmount,\n            _path,\n            address(this),\n            block.timestamp.add(1)\n        );\n    }\n\n    /// @notice Swap ETH to ERC20 Token\n    function __swapETHToToken(\n        uint256 _payoutAmount,\n        uint256 _expectedAmount,\n        address _router,\n        address[] memory _path\n    ) public payable returns (uint256[] memory amounts_) {\n        __approveMaxAsNeeded(_path[0], _router, _payoutAmount);\n\n        amounts_ = IUniswapV2Router2(_router).swapExactETHForTokens{value: address(this).balance}(\n            _expectedAmount,\n            _path,\n            address(this),\n            block.timestamp.add(1)\n        );\n    }\n\n    /// @notice get LP token on uniswap/sushiswap\n    /// @param _factory factory address of uni/sushi\n    /// @param _router router address of uni/sushi\n    /// @param _path address[]\n    /// @param _amountADesired tokenA amount\n    /// @param _amountBDesired tokenB amount\n    /// @return lpAddress_ lp token address\n    /// @return lpAmount_ lp token amount\n    function addLiquidityToken(\n        address _factory,\n        address _router,\n        address[] memory _path,\n        uint256 _amountADesired,\n        uint256 _amountBDesired        \n    )\n        private  \n        returns (address lpAddress_, uint256 lpAmount_)\n    {\n        lpAmount_ = __addTokenAndToken(\n            _router,\n            _path,\n            _amountADesired,\n            _amountBDesired\n        );                \n\n        lpAddress_ = IUniswapV2Factory(_factory).getPair(_path[0], _path[1]);\n\n        __transferAssetToCaller(msg.sender, lpAddress_);        \n    }\n\n    /// @notice addLiquidity for lp tokens on Uniswap/Sushi\n    function __addTokenAndToken(\n        address _router,\n        address[] memory _path,\n        uint256 _amountADesired,\n        uint256 _amountBDesired\n    ) private returns (uint256 lpAmount_) {\n        __approveMaxAsNeeded(_path[0], _router, _amountADesired);\n        __approveMaxAsNeeded(_path[1], _router, _amountBDesired);\n        \n        // Get expected output amount on Uniswap/Sushi\n        address[] memory path = new address[](2);\n        path[0] = _path[1];\n        path[1] = _path[0];\n        uint256 amountAMax = IUniswapV2Router2(_router).getAmountsOut(_amountBDesired, path)[1];\n        \n        // Execute addLiquicity on Uniswap/Sushi\n        (, , lpAmount_) = IUniswapV2Router2(_router).addLiquidity(\n            _path[0],\n            _path[1],\n            amountAMax,\n            _amountBDesired,\n            1,\n            1,\n            msg.sender,\n            block.timestamp.add(1)\n        );\n    }\n\n    /// @dev Helper to decode swap encoded call arguments\n    function __decodeSwapArgs(bytes memory _encodedCallArgs)\n        private\n        pure\n        returns (\n            uint256 depositAmount_,\n            address depositAsset_,\n            address payoutAsset_,\n            address incomingAsset_\n        )\n    {\n        return abi.decode(_encodedCallArgs, (uint256, address, address, address));\n    }\n\n    /// @dev Helper for asset to approve their max amount of an asset.\n    function __approveMaxAsNeeded(\n        address _asset,\n        address _target,\n        uint256 _neededAmount\n    ) private {\n        if (IERC20(_asset).allowance(address(this), _target) < _neededAmount) {\n            IERC20(_asset).safeApprove(_target, type(uint256).max);\n        }\n    }\n\n    /// @dev Helper to transfer full contract balances of assets to the caller\n    function __transferAssetToCaller(address payable _target, address _asset) private {\n        uint256 transferAmount;\n        if(_asset == address(ETH_ADDRESS) || _asset == address(0)) {\n            transferAmount = address(this).balance;\n            if (transferAmount > 0) {\n                _target.transfer(transferAmount);\n            }\n        } else {\n            transferAmount = IERC20(_asset).balanceOf(address(this));\n            if (transferAmount > 0) {\n                IERC20(_asset).safeTransfer(_target, transferAmount);\n            }\n        }        \n    }\n\n    /// @dev check if special pool exist on uniswap or sushiswap\n    function __checkPool(address[] memory _path) private view returns (address router_, address factory_) {        \n        address uniPool = IUniswapV2Factory(UNISWAP2_FACTORY).getPair(_path[0], _path[1]);   \n        address sushiPool = IUniswapV2Factory(SUSHI_FACTORY).getPair(_path[0], _path[1]);\n        \n        if(uniPool == address(0) && sushiPool != address(0)) {\n            return (SUSHI_ROUTER, SUSHI_FACTORY);\n        } else if(uniPool != address(0) && sushiPool == address(0)) {\n            return (UNISWAP2_ROUTER, UNISWAP2_FACTORY);\n        } else if(uniPool != address(0) && sushiPool != address(0)) {\n            return (UNISWAP2_ROUTER, UNISWAP2_FACTORY);\n        } else if(uniPool == address(0) && sushiPool == address(0)) {\n            return (address(0), address(0));\n        }\n    }\n\n    /// @notice Gets the `UNISWAP2_FACTORY` variable\n    function getUniswapFactory() external view returns (address factory_) {\n        return UNISWAP2_FACTORY;\n    }\n\n    /// @notice Gets the `SUSHI_FACTORY` variable\n    function getSushiFactory() external view returns (address factory_) {\n        return SUSHI_FACTORY;\n    }\n\n    /// @notice Gets the `UNISWAP2_ROUTER` variable\n    function getUniswapRouter() external view returns (address router_) {\n        return UNISWAP2_ROUTER;\n    }\n\n    /// @notice Gets the `SUSHI_ROUTER` variable\n    function getSushiRouter() external view returns (address router_) {\n        return SUSHI_ROUTER;\n    }\n}\n"
    },
    "src/interfaces/IUniswapV2Router2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\n/// @title UniswapV2Router2 Interface\ninterface IUniswapV2Router2 {\n\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address,\n        address,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        uint256\n    ) external returns (uint256, uint256);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n    \n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    },
    "src/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n\npragma solidity 0.7.5;\n\n/// @title IUniswapV2Factory Interface\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "src/bonding/SubsidyRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\nimport \"../types/BondOwnable.sol\";\n\ninterface IBond {\n    function paySubsidy() external returns ( uint );\n}\n\n// Immutable contract routes between Olympus Pro bonds and subsidy controllers\n// Allows for subsidies on bonds offered through bond contracts\ncontract SubsidyRouter is BondOwnable {\n\n    mapping( address => address ) public bondForController; // maps bond contract managed by subsidy controller\n\n    /**\n     *  @notice subsidy controller fetches and resets payout counter\n     *  @return uint\n     */\n    function getSubsidyInfo() external returns ( uint ) {\n        require(bondForController[msg.sender] != address(0), \"Address not mapped\" );\n        return IBond(bondForController[msg.sender]).paySubsidy();\n    }\n\n    /**\n     *  @notice add new subsidy controller for bond contract\n     *  @param _bond address\n     *  @param _subsidyController address\n     */\n    function addSubsidyController( address _bond, address _subsidyController ) external onlyPolicy() {\n        require(_bond != address(0), \"SubsidyRouter: bond must not be zero address\");\n        require(_subsidyController != address(0), \"SubsidyRouter: controller must not be zero address\");\n\n        bondForController[_subsidyController] = _bond;\n    }\n\n    /**\n     *  @notice remove subsidy controller for bond contract\n     *  @param _subsidyController address\n     */\n    function removeSubsidyController(address _subsidyController) external onlyPolicy() {\n        bondForController[_subsidyController] = address(0);\n    }\n}"
    },
    "src/bonding/FactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.5;\n\nimport \"../types/BondOwnable.sol\";\n\ncontract FactoryStorage is BondOwnable {\n    struct BondDetails {\n        address _payoutToken;\n        address _principleToken;\n        address _treasuryAddress;\n        address _bondAddress;\n        address _initialOwner;\n    }\n\n    BondDetails[] public bondDetails;\n\n    address public factory;\n\n    mapping(address => uint256) public indexOfBond;\n\n    event NewBond(address treasury, address bond, address _initialOwner);\n\n    /* ======== POLICY FUNCTIONS ======== */\n\n    /**\n        @notice pushes bond details to array\n        @param _payoutToken address\n        @param _principleToken address\n        @param _customTreasury address\n        @param _customBond address\n        @param _initialOwner address\n        @return _treasury address\n        @return _bond address\n     */\n    function pushBond(\n        address _payoutToken,\n        address _principleToken,\n        address _customTreasury,\n        address _customBond,\n        address _initialOwner\n    ) external returns(address _treasury, address _bond) {\n\n        require(msg.sender == factory, \"Not Factory\");\n\n        indexOfBond[_customBond] = bondDetails.length;\n\n        bondDetails.push(\n            BondDetails({\n                _payoutToken: _payoutToken,\n                _principleToken: _principleToken,\n                _treasuryAddress: _customTreasury,\n                _bondAddress: _customBond,\n                _initialOwner: _initialOwner\n            })\n        );\n\n        emit NewBond(_customTreasury, _customBond, _initialOwner);\n\n        return(_customTreasury, _customBond);\n    }\n    /**\n        @notice get bondDetails count\n     */\n    function bondDetailsCount() public view returns(uint count) {\n        return bondDetails.length;\n    }\n\n    /**\n        @notice changes flux pro factory address\n        @param _factory address\n     */\n    function setFactoryAddress(address _factory) external onlyPolicy {\n        factory = _factory;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}